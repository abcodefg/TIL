package programmers;

/*계속되는 폭우로 일부 지역이 물에 잠겼습니다.
* 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다.
* 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.
*
* 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다.
* 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.
*
* (제한사항)
* - 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
* - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
* - 물에 잠긴 지역은 0개 이상 10개 이하입니다.
* - 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.
 */
public class DP_등굣길 {
    /**
     * 집에서부터 오른쪽과 아래쪽으로만 움직여 이동할 때, 어떤 지역에 도착하는 최단 경로의 개수는
     * 해당 지역의 바로 왼쪽에 있는 지역에 도착하는 최단 경로의 개수 + 바로 위쪽에 있는 지역에 도착하는 최단 경로의 개수이다.
     *
     * 여기서 문제 풀이를 위해 추가로 고려해야 하는 크게 세 가지이다.
     *  1. 격자를 기준으로 맨 왼쪽(위쪽)에 위치해 있는 지역들은 그보다 더 왼쪽(위쪽)에 위치한 지역이 없으므로
     *      바로 위쪽(왼쪽)에 있는 지역에 도착하는 최단 경로의 개수(=1)를 그대로 이어받는다.
     *  2. 물에 잠기지 않은 지역을 통해 학교를 가야 하므로, 물에 잠긴 지역에 도착하는 최단 경로의 개수는 0이다.
     *  3. 특정 지역에 도착하는 최단경로의 개수를 기록해둔다면 풀이가 더 빠르게 이루어질 수 있다.
     *      예를 들어, 어떤 지역 x에 도착하는 최단 경로의 개수를 f(x)이고, 학교 가는 길에 다음과 같은 격자구조로 나열된 지역을 지나간다고 하자.
     *      ...  a  b ...
     *      ...  c  d ...
     *      이때, f(d)를 구할 때 f(b)와 f(c)의 값을 알고 있다면, 각각의 값을 구하기 위해 시작점까지 거슬러가는 연산을 되풀이할 필요가 없으므로
     *      풀이에 걸리는 시간이 단축될 것이다.
     *
     * 동일한 형태의 연산이 직전 연산의 영향을 받으며 반복되며 기록을 통해 풀이 시간을 단축할 수 있으므로 Dynamic programming 으로 풀 수 있다.
     */
    private Integer[][] map;
    public int solution(int m, int n, int[][] puddles) {

        map = new Integer[m+1][n+1];
        for (int[] puddle : puddles) {
            map[puddle[0]][puddle[1]] = 0;
        }

        // 집에서 출발하는 경우의 수는 1가지이다.
        map[1][1] = 1;

        return dp(m, n);
    }

    private int dp(int m, int n) {
        if (map[m][n] != null)
            return map[m][n];

        // 맨 왼쪽(위쪽)에 위치한 지역까지의 최단 경로의 개수는 바로 위쪽(왼쪽)까지의 최단 경로의 개수와 같다.
        if (m == 1)
            map[m][n] = dp(m , n - 1);
        else if (n == 1)
            map[m][n] = dp(m - 1, n);

        // 다른 지역들까지의 최단 경로의 개수는 바로 왼쪽 지역까지의 최단 경로의 개수와 위쪽 지역까지의 최단 경로의 개수를 더한 값과 같다.
        else
            map[m][n] = (dp(m - 1, n) + dp(m, n - 1)) % 1000000007;

        return map[m][n];
    }

    /**
     * 내 경우엔 TOP-DOWN 방식으로 풀었는데, 다른 분의 풀이 중 BOTTOM-UP 방식으로 접근한 좋은 풀이가 있어 기록한다.
     * 단순히 접근법이 다른 것 뿐만 아니라, 가장자리에 위치한 지역을 포함한 모든 지역의 최단 경로의 개수를 통합해서 다룰 수 있다는 점에서
     * 기록해두고 볼 필요가 있는 훨씬 세련된 풀이인 것 같다.
     */

    public int solution2(int m, int n, int[][] puddles) {
        map = new Integer[m+1][n+1];
        for (int[] puddle : puddles) {
            map[puddle[0]][puddle[1]] = -1;
        }

        map[1][1] = 1;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (map[i][j] == -1) {
                    map[i][j] = 0;
                    continue;
                }
                // TODO 확인할 것 : 각기 다른 조건들을 간결하게 통합
                //  53-62번까지의 코드랑 비교해볼 것
                if(i!=1)    map[i][j] += map[i-1][j] % 1000000007;
                if(j!=1)    map[i][j] += map[i][j-1] % 1000000007;
            }
        }

        return map[m][n] % 1000000007;
    }
}
