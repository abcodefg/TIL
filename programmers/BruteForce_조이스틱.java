package programmers;
/*조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
* ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA
* 조이스틱을 각 방향으로 움직이면 아래와 같습니다.
* ▲ - 다음 알파벳
* ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
* ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
* ▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)
*
* 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.
*/
public class BruteForce_조이스틱 {
    /**
     * 'A'를 name을 구성하는 어떤 알파벳으로 변경하는 데 필요한
     * ▲, ▼ 조작 횟수의 최솟값을 구하는 것은 간단하였으나,
     * ◀, ▶ 조작 횟수의 최솟값을 파악하기가 까다로웠고 결국 다른 분의 풀이를 참고했다..
     *
     * 이를 까다롭게 만드는 조건은 다음과 같다.
     * 1) name을 구성하는 알파벳 중 'A'는 변경하지 않아도 되고, 따라서 가능하다면 좌우 조작을 통해 방문하지 않아도 된다.
     * 2) 첫 번째(마지막) 위치에서 왼쪽(오른쪽)으로 이동하면 마지막(첫 번째) 문자로 커서가 옮겨진다.
     *
     * 1)과 2)가 아니었다면, a)오른쪽으로만 이동하는 경우만 고려하면 되므로,
     * 좌우 조작 횟수의 최솟값은 (name의 길이 - 1)일 것이다.
     *
     * 그러나 1)과 2)로 인해 name에 'A'가 있는 경우에는
     * 변경하지도 않을 1개 이상의 'A'를 지나치는 것보다
     * 방향을 바꿔 돌아가는 편이 조작 횟수가 적을 수 있으므로,
     *   b) 오른쪽으로 가다가 왼쪽으로 가는 경우
     *   c) 왼쪽으로 가다가 오른쪽으로 가는 경우
     * 역시 고려해야 한다.
     */
    public int solution(String name) {

        int answer = 0;
        int len = name.length();
        // 오른쪽으로만 이동한다면 좌우 조작의 최솟값은 name의 길이 - 1
        int min = len - 1;

        for (int i = 0; i < len; i++) {
            char c = name.charAt(i);
            // 상하 조작의 최솟값을 더한다.
            answer += Math.min(c - 'A', 'Z' - c + 1);

            int next = i + 1;
            //'A'가 연속해서 나타나는 구간이 끝나는 인덱스 next를 구한다.
            while (next < len && name.charAt(next) == 'A')
                next++;
            // (1) 오른쪽으로만 이동할 때의 조작 횟수
            // (2) 오른쪽으로 i까지 이동하다가 방향을 바꿔 왼쪽으로 next까지 이동할 때의 조작 횟수
            // (3) 처음부터 왼쪽으로 next까지 이동하다가 방향을 바꿔 오른쪽으로 i까지 이동할 때의 조작 횟수
            // 중 에서 가장 작은 값이 min
            min = Math.min(min, Math.min((i * 2) + len - next, i + (len - next) * 2));
        }

        answer += min;

        return answer;
    }
}
